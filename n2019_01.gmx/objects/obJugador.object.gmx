<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spAldo0</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Info
/**************************************************************
Aldo es el protagonista del juego.
Acaba de llegar al pueblo y las Posadas están a punto de comenzar.

Este objeto es controlado por el jugador.
Se mueve en 8 direcciones usando 4 botones o se desplaza al
punto indicado con un clic en la ventana de juego.

Utiliza la ruta ptJugador para guardar el resultado de path-finding.

Caminar con botones y haciendo clic con ratón
[x] Primero centrar sprite

[] Probar método sin alineación
La posición final del personaje no siempre es alineada
a la rejilla.
**************************************************************/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Variables

x += 32; //desplazar para alinear a la rejilla
y += 32;
vx = 0; //velocidad horizontal
vy = 0; //velocidad vertical
v = 4; //velocidad de desplazamiento
direction = 270; //inicia mirando hacia abajo
dirPrev = 270; //direction previa

// Las siguientes variables se utilizan cuando el personaje
// cambia la dirección a la que está mirando, es decir, se acaba de 
// presionar un botón de movimiento diferente al último presionado.
// En ese momento la dirección cambia y se pone el sprite adecuado.
// El personaje no puede caminar hasta que el temporizador llegue a cero.
tReposo = 0; //temporizador de reposo
T_REPOSO = 1; //periodo de reposo en steps

/// Iniciar sistema de búsqueda de ruta

grid = mp_grid_create(0, 0, 1280/64, 720/64, 64, 64);
// 1280/64 = 20
// 720/64 = 11.25

// también se usa la ruta ptJugador

// para saber si el objeto sigue a una ruta
// se usa la variable path_index (&gt; -1)

//agregar objetos a la rejilla
mp_grid_add_instances(grid, obBloque, false);

// Caja de colisión personalizada
boxL = 32;
boxR = 32;
boxU = 32;
boxD = 32;

// pos previa
xPrev = x;
yPrev = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movimiento

// Teclado
der = keyboard_check(vk_right) or keyboard_check(ord('D'));
izq = keyboard_check(vk_left) or keyboard_check(ord('A'));
arr = keyboard_check(vk_up) or keyboard_check(ord('W'));
aba = keyboard_check(vk_down) or keyboard_check(ord('S'));

// ejes de un joystick imaginario
ejeX = der - izq;
ejeY = aba - arr;
vx = 0;
vy = 0;

if (ejeX &lt;&gt; 0 or ejeY &lt;&gt; 0) //si el joystick está desplazado
{
   path_end();
   direction = point_direction(0, 0, ejeX, ejeY);
   if (direction &lt;&gt; dirPrev) {//si direction ha cambiado
      tReposo = T_REPOSO; //iniciar temporizador
      dirPrev = direction; //actualizar direction previa
   }
   
   if (tReposo &lt;= 0) {
      vx = lengthdir_x(v, direction);
      vy = lengthdir_y(v, direction);
   }
}

// Mouse
if mouse_check_button_pressed(mb_left) {//si se hace clic
   metaX = (mouse_x div 64)*64 + 32; //obtener posicion final
   metaY = (mouse_y div 64)*64 + 32;
   
   //si se encuentra una ruta, seguirla
   if mp_grid_path(grid, ptJugador, x, y, metaX, metaY, true) {
      path_start(ptJugador, v, path_action_stop, true);
   }
}

if (tReposo &gt; 0) tReposo--;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Colisiones

// Horizontal
xPrev = x; //guardar pos. previa
x += vx; //desplazar horizontalmente

// revisar colisiones con bloques solidos
bloque = instance_place(x, y, obBloque);
if (bloque &lt;&gt; noone) {
   if (bloque.x &lt; x) { //bloque a la izquierda
      x = bloque.x + bloque.sprite_width + boxL;
   }
   else {//bloque a la derecha
      x = bloque.x - boxR;
   }
   vx = 0;
}

//no salir por la izquierda de la room
if (x &lt; boxL) {x = boxL;  vx = 0;}
//no salir por la derecha de la room
if (x+boxR &gt; room_width) {x = room_width-boxR;  vx = 0;}

// Vertical
yPrev = y; //guardar posicion previa
y += vy; //desplazar verticalmente

// Revisar colisiones con bloques solidos
bloque = instance_place(x, y, obBloque);
if (bloque &lt;&gt; noone) {
   if (bloque.y &lt; y) {//bloque arriba
      y = bloque.y + bloque.sprite_height + boxU;
   }
   else {//bloque abajo
      y = bloque.y - boxD;
   }   
   vy = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Borrar estructuras dinámicas

mp_grid_destroy(grid);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Depuración

//mp_grid_draw(grid);
draw_self();
draw_path(ptJugador, 0, 0, true);

draw_text(0, 0, direction);
draw_text(0, 24, path_index);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
